import ast
import re
from supported_strategies import supportedStrategies
# from import_structs import ImportStructure
from auxiliary_files.import_structs import ImportStructure


def rewriteImports(source, newStructure: ImportStructure):
    sourceWOimports = removeImports(source)
    imports = newStructure.toSource() + "\n"
    imports += "# This test code was written by the `hypothesis.extra.ghostwriter` module\n# and is provided under the Creative Commons Zero public domain dedication\n\n\n"
    return imports + sourceWOimports

def removeImports(source: str):
    tree = ast.parse(source)
    for node in ast.walk(tree):
        if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):
            if node in tree.body:
                tree.body.remove(node)
    return ast.unparse(tree)    

def removeComments(source: str):
    return ast.unparse(ast.parse(source))

def replaceNothingPlaceholder(pbt: str):
    i = 1

    def makeStrategyPlaceholder():
        nonlocal i
        temp = "${" + str(i) + "|"
        for strat in supportedStrategies.values():
            temp += strat + ","
        temp = temp[:-1]
        temp += "|}"
        i += 1
        return temp
    
    def replace(match):
        return makeStrategyPlaceholder()

    result = re.sub(r"st\.nothing\(\)", replace, pbt) + "\n\n"
    result = result.replace("'", "")
    return result

def getTestFileName(fileName, pattern):
    result = fileName[0 : -3] # removes the .py suffix
    result += pattern
    result += ".py"
    return result

def fishOutPbt(pbtSource, selectedPbtName):
    tree = ast.parse(pbtSource)
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef) and node.name == selectedPbtName:
            return (ast.unparse(node), node.lineno, node.col_offset)
    
    return (None, None, None)

def getArgsFromPbt(pbt):
    def getGivenNode(tree):
        for node in ast.walk(tree):
            if isinstance(node, ast.Call) and node.func.id == "given":
                # print("func: ", node.func, " ## ", "keywords: ", node.keywords, " ## " "args: ", node.args, " ## " "type: ", type(node))
                return node
    
    tree = ast.parse(pbt)
    givenNode = getGivenNode(tree)
    args = list(map(lambda keyword: keyword.arg, givenNode.keywords))

    return args

def getArgsFromSut(sut):
    def getFunctionNode(tree):
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                # print("func: ", node.func, " ## ", "keywords: ", node.keywords, " ## " "args: ", node.args, " ## " "type: ", type(node))
                return node
    
    tree = ast.parse(sut)
    functionNode = getFunctionNode(tree)
    args = list(map(lambda arg: arg.arg, functionNode.args.args))

    return args



def split_generated_code(pbt):
    """Splits code generated by hypothesis into imports and the actual PBT"""
    
    tree = ast.parse(pbt)
    importNodes = []

    for node in ast.walk(tree):
        if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):
            importNodes += [ast.unparse(node)]
            tree.body.remove(node)

    return (ast.unparse(tree), importNodes)

def getParameters(pbt):
    tree = ast.parse(pbt)

    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            temp = list(map(lambda x: x.arg, node.args.posonlyargs + node.args.args))
            if "self" in temp:
                temp.remove("self") # Should stay in case the SUT is a class method
            return temp

def makeCustomGenerators(customArgStrategyZip, sutName):
    def createCustomStrategy(argName):
        strategyName = "strategyFor_" + argName + "_in_" + sutName
        strategy = "def " + strategyName + "():\n\t"
        strategy += "return st.nothing()\n\n"
        return strategy, strategyName

    strategiesString = "" # source of all strategies combined
    strategiesNames = [] # name of custom strategy function
    argNames = [] # names of args

    for name, makeCustomStrategy in customArgStrategyZip:
        argNames += [name]
        if makeCustomStrategy:
            strategySource, strategyName = createCustomStrategy(name)
            strategiesString += strategySource
            strategiesNames += [strategyName]
        else:
            strategiesNames += ["st.nothing"]

    print("\n")
    print(customArgStrategyZip)
    print(argNames)
    print(strategiesNames)


    return strategiesString, argNames, strategiesNames

def getSutSourceList(source: str, sutNames: list[str]):
    tree = ast.parse(source)
    result = []

    def isClassMethod(name: str):
        return '.' in name
    
    def lookupFunction(tree, funcName):
        nonlocal result
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                if node.name == funcName:
                    result += [ast.unparse(node)]
                    return

    def lookupClass(tree, className, methodName):
        nonlocal result
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                if node.name == className:
                    # return lookupFunction(node, methodName) # This line returns the method, not the entire class
                    result += [ast.unparse(node)]
                    return

    for sut in sutNames:
        if isClassMethod(sut):
            (className, methodName) = sut.split('.')
            lookupClass(tree, className, methodName)
        else:
            lookupFunction(tree, sut)

    return result
        
def getEvaluatedSouceList(sutNames, sutSourceList):
    # Make copy of environment and evaluate the source
    env = globals().copy()
    fullSource = "\n".join(sutSourceList)
    exec(fullSource, env)
    
    # Put all evaluated functions in a list
    result = []
    for name in sutNames:
        result += [env[name]]

    return result
